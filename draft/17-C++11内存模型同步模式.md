C++11内存模型同步模式
==

（翻译自[AtomSync](https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync)）

绝大数人们在研究内存模型的时候都发现这个领域非常令人困惑。__原子变量主要被用来在线程之间同步共享内存访问。__ 一般的一个线程船舰了数据，然后存储到一个原子变量中。其他的线程读取这个原子变量，并且在读取到期望值的时候，这个被其他线程创建的值在当前线程可见了。不同的内存模型模式用来表示线程之间这种数据共享的联系有多强。富有经验的程序员们能够利用其中较弱的模型使软件更加高效。

Each atomic class has a load() and a store() operation which is utilized to perform assignments. This helps make it clearer when atomic operations are being performed rather than a normal assignment.

每一个原子类都有一个`load()`和执行赋值的`store()`操作。这使得执行原子操作比普通赋值更加清晰。
```cpp
  atomic_var1.store(atomic_var2.load()); // atomic variables
    vs
  var1 = var2;
```

这些操作也都有第二个可选的参数，用来指出用来同步的内存模型模式。

一共有三种模型，或者说模式允许程序员支持跨线程同步的类型。

顺序一致模式
--

第一种模型叫做“顺序一致”。如果没有指明那么这就是默认模式，并且也是最严格的。当然也可以通过`std::memory_order_seq_cst`显式地指明。它对前后移动读取操作提出了一致的限制和局限性要求，这是习惯顺序编程的程序员所熟悉的，只是把它应用到了线程之间的操作。

```cpp
-Thread 1-       -Thread 2-
y = 1            if (x.load() == 2)
x.store (2);        assert (y == 1)
```
虽然`x`与`y`是完全无关的变量，这种内存模型要求断言一定不能失败。线程1中存储到`y`的动作发生在存储到`x`的动作之前。如果线程2中`x`的读取读到了发生在线程1中存储的值，那它也必然看到了所有发生在线程1中发生在存储动作之前的所有操作，哪怕是没有关系的那些操作。这意味着优化器在线程1中不能任意的重新排序这两次存储，因为线程2也必须看到`y`的存储。

这个模型也使用于读取：

```cpp
              a = 0
              y = 0
              b = 1
-Thread 1-              -Thread 2-
x = a.load()            while (y.load() != b)
y.store (b)                ;
while (a.load() == x)   a.store(1)
   ;
```

线程2持续循环直至`y`的值发生变化，然后继续改变`a`。线程1一致在等待`a`的变化。

一般情况下便宜顺序执行的代码，线程1的`while (a.load() == x)`看起来像是一个无限循环，并且有可能因此被优化掉。然而，`a`的读取以及与`x`的比较都必须在循环的每一次迭代发生从而使线程1和线程2正常运行。

从实际的角度看，这等于所有的原子操作都是优化屏障。如果把原子读取和存储操作看作是有着未知副作用的函数调用，那么我们可以在优化器中对这种影响建模。在原子操作之间重新排序其他操作是OK的，但是它不能越过这些原子操作。与线程本地相关的内容也不受影响，毕竟它们对于其他线程是不可见的。

这种模式也提供了跨所有线程的一致性。下面例子中的断言都不会失败（其中`x`和`y`都被初始化为0）：

```cpp
-Thread 1-       -Thread 2-                   -Thread 3-
y.store (20);    if (x.load() == 10) {        if (y.load() == 10)
x.store (10);      assert (y.load() == 20)      assert (x.load() == 10;
                   y.store (10);
                 }
```

这看起来期待这种行为是很合理的，但是跨线程实现需要同步系统总线使得线程3可以获取线程2观察到的一致的结果。而这会引入某些代价非常高的硬件同步。

有相当的理由把这种模式设为默认模式，因为程序员们在这种模式下不会获得太出人意料的结果。

宽松模式
--

那正相反的方式就是`std::memory_order_relaxed`。这种模式去掉了*在...之前发生*的限制从而允许更少的同步发生。这种类型的原子操作于是也有了更多的优化操作空间，例如移除无用的存储，或是移除共通部分。

于是在早前的例子中：

```cpp
-Thread 1-
y.store (20, memory_order_relaxed)
x.store (10, memory_order_relaxed)

-Thread 2-
if (x.load (memory_order_relaxed) == 10)
{
  assert (y.load(memory_order_relaxed) == 20) /* assert A */
  y.store (10, memory_order_relaxed)
}

-Thread 3-
if (y.load (memory_order_relaxed) == 10)
  assert (x.load(memory_order_relaxed) == 10) /* assert B */
```

既然线程之间不再需要同步，例子中任一断言在实际情况中都可以失败。

没有了任何*在...之前发生*的保护，没有线程能依赖另外一个线程特定的执行顺序。如果不小心的话这样很明显会导致某些出乎意料的结果。唯一还起作用的就是一旦线程1中某个变量的值在线程2中可见，那么线程2就不能再看到这个变量更早先的值了，例如，假设`x`被初始化为0：

```cpp
-Thread 1-
x.store (1, memory_order_relaxed)
x.store (2, memory_order_relaxed)

-Thread 2-
y = x.load (memory_order_relaxed)
z = x.load (memory_order_relaxed)
assert (y <= z)
```

这个断言是不会失败的。一旦存储2这个值在线程2可见，那值1就不再可见了。这防止了将一个变量宽松的读取与另外一个可能有别名的引用的宽松读取合并一起的事发生（译者注：没太懂。。。）

这里还有一个假设，在一个线程上执行的宽松存储可以在一段合理的时间范围内被另外一个线程宽松的读取。这意味着在非缓存相关架构上，宽松的操作必须刷新缓存（即使这些刷新会合并数个宽松的操作）。

这种宽松模式绝大部分用在了程序员只需要变量体现原子性而不是在线程间同步共享数据。

获取/释放模式
--

第三种模式是前两种模式的混合体。获取/释放模式与顺序一致模式很像，但是它只应用*在...之前发生*于依赖变量。这允许在独立读取和独立写入之间宽松同步。

假设`x`和`y`都被初始化为0：

```cpp
-Thread 1-
y.store (20, memory_order_release);

-Thread 2-
x.store (10, memory_order_release);

-Thread 3-
assert (y.load (memory_order_acquire) == 20 && x.load (memory_order_acquire) == 0)

-Thread 4-
assert (y.load (memory_order_acquire) == 0 && x.load (memory_order_acquire) == 10)
```
两个断言都可以通过，毕竟线程1和线程2的两次存储没有强加任何关系。

如果这个例子使用顺序一致模型来写的话，那其中的一次存储必然要*在*另一次存储*之前发生*（即使顺序直到运行时才确定），而后变量值在线程之间同步，如果一个断言通过，那么另外一个断言一定失败。

把事情变得更复杂一些，非原子变量的相互作用还是不变的，任何发生在原子操作之前的存储必须被同步的其他线程可见。例如：

```cpp
-Thread 1-
y = 20;
x.store (10, memory_order_release);

-Thread 2-
if (x.load(memory_order_acquire) == 10)
   assert (y == 20);
```

因为`y`不是一个原子变量，对`y`的存储在对`x`的存储之前发生，所以在这种情况下断言不会失败。优化器必须限制对原子操作附近共享内存变量的操作。

消费模式
--

`std:memory_order_consume`是对获取/释放模式进一步细微的改进，它稍稍放宽了要求，去除了对非依赖共享变量的顺序要求。

假设`n`与`m`都是一般共享变量，初始化为0，并且每一个线程尝试获取线程1存储到p的值：

```cpp
-Thread 1-
n = 1
m = 1
p.store (&n, memory_order_release)

-Thread 2-
t = p.load (memory_order_acquire);
assert( *t == 1 && m == 1 );

-Thread 3-
t = p.load (memory_order_consume);
assert( *t == 1 && m == 1 );
```

线程2中的断言会通过，因为在线程1存储到`m`在存储到`p`之前发生。

线程3中的断言则可以失败，因为存储到`p`与存储到`m`之间不再有依赖关系，于是它们的值不再需要同步。这是PowerPC以及ARM架构指针加载的默认内存顺序。（也有可能是某些MIPs的模型）。

两个线程都可以看到n为1这个正确的值，因为它用在了存储表达式中。

真正测差别则归结为硬件到底要刷新多少个状态从而保持同步。既然一个消费操作因而执行得更快，某些知道自己在做什么的人可以使用它来写那些对性能极其敏感的应用程序。
