# C++11内存模型同步模式

（翻译自[AtomSync](https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync)）

绝大数人们在研究内存模型的时候都发现这个领域非常令人困惑。__原子变量主要被用来在线程之间同步共享内存访问。__ 一般的一个线程船舰了数据，然后存储到一个原子变量中。其他的线程读取这个原子变量，并且在读取到期望值的时候，这个被其他线程创建的值在当前线程可见了。不同的内存模型模式用来表示线程之间这种数据共享的联系有多强。富有经验的程序员们能够利用其中较弱的模型使软件更加高效。

每一个原子类都有一个`load()`和执行赋值的`store()`操作。这使得执行原子操作比普通赋值更加清晰。
```cpp
  atomic_var1.store(atomic_var2.load()); // atomic variables
    vs
  var1 = var2;
```

这些操作也都有第二个可选的参数，用来指出用来同步的内存模型模式。

一共有三种模型，或者说模式允许程序员支持跨线程同步的类型。

## 顺序一致模式

第一种模型叫做“顺序一致”。如果没有指明那么这就是默认模式，并且也是最严格的。当然也可以通过`std::memory_order_seq_cst`显式地指明。它对前后移动读取操作提出了一致的限制和局限性要求，这是习惯顺序编程的程序员所熟悉的，只是把它应用到了线程之间的操作。

```cpp
-Thread 1-       -Thread 2-
y = 1            if (x.load() == 2)
x.store (2);        assert (y == 1)
```
虽然`x`与`y`是完全无关的变量，这种内存模型要求断言一定不能失败。线程1中存储到`y`的动作发生在存储到`x`的动作之前。如果线程2中`x`的读取读到了发生在线程1中存储的值，那它也必然看到了所有发生在线程1中发生在存储动作之前的所有操作，哪怕是没有关系的那些操作。这意味着优化器在线程1中不能任意的重新排序这两次存储，因为线程2也必须看到`y`的存储。

这个模型也使用于读取：

```cpp
              a = 0
              y = 0
              b = 1
-Thread 1-              -Thread 2-
x = a.load()            while (y.load() != b)
y.store (b)                ;
while (a.load() == x)   a.store(1)
   ;
```

线程2持续循环直至`y`的值发生变化，然后继续改变`a`。线程1一致在等待`a`的变化。

一般情况下便宜顺序执行的代码，线程1的`while (a.load() == x)`看起来像是一个无限循环，并且有可能因此被优化掉。然而，`a`的读取以及与`x`的比较都必须在循环的每一次迭代发生从而使线程1和线程2正常运行。

从实际的角度看，这等于所有的原子操作都是优化屏障。如果把原子读取和存储操作看作是有着未知副作用的函数调用，那么我们可以在优化器中对这种影响建模。在原子操作之间重新排序其他操作是OK的，但是它不能越过这些原子操作。与线程本地相关的内容也不受影响，毕竟它们对于其他线程是不可见的。

这种模式也提供了跨所有线程的一致性。下面例子中的断言都不会失败（其中`x`和`y`都被初始化为0）：

```cpp
-Thread 1-       -Thread 2-                   -Thread 3-
y.store (20);    if (x.load() == 10) {        if (y.load() == 10)
x.store (10);      assert (y.load() == 20)      assert (x.load() == 10;
                   y.store (10);
                 }
```

这看起来期待这种行为是很合理的，但是跨线程实现需要同步系统总线使得线程3可以获取线程2观察到的一致的结果。而这会引入某些代价非常高的硬件同步。

有相当的理由把这种模式设为默认模式，因为程序员们在这种模式下不会获得太出人意料的结果。

## 宽松模式

那正相反的方式就是`std::memory_order_relaxed`。这种模式去掉了*在...之前发生*的限制从而允许更少的同步发生。这种类型的原子操作于是也有了更多的优化操作空间，例如移除无用的存储，或是移除共通部分。

于是在早前的例子中：

```cpp
-Thread 1-
y.store (20, memory_order_relaxed)
x.store (10, memory_order_relaxed)

-Thread 2-
if (x.load (memory_order_relaxed) == 10)
{
  assert (y.load(memory_order_relaxed) == 20) /* assert A */
  y.store (10, memory_order_relaxed)
}

-Thread 3-
if (y.load (memory_order_relaxed) == 10)
  assert (x.load(memory_order_relaxed) == 10) /* assert B */
```

既然线程之间不再需要同步，例子中任一断言在实际情况中都可以失败。

没有了任何*在...之前发生*的保护，没有线程能依赖另外一个线程特定的执行顺序。如果不小心的话这样很明显会导致某些出乎意料的结果。唯一还起作用的就是一旦线程1中某个变量的值在线程2中可见，那么线程2就不能再看到这个变量更早先的值了，例如，假设`x`被初始化为0：

```cpp
-Thread 1-
x.store (1, memory_order_relaxed)
x.store (2, memory_order_relaxed)

-Thread 2-
y = x.load (memory_order_relaxed)
z = x.load (memory_order_relaxed)
assert (y <= z)
```

这个断言是不会失败的。一旦存储2这个值在线程2可见，那值1就不再可见了。这防止了将一个变量宽松的读取与另外一个可能有别名的引用的宽松读取合并一起的事发生（译者注：没太懂。。。）

这里还有一个假设，在一个线程上执行的宽松存储可以在一段合理的时间范围内被另外一个线程宽松的读取。这意味着在非缓存相关架构上，宽松的操作必须刷新缓存（即使这些刷新会合并数个宽松的操作）。

这种宽松模式绝大部分用在了程序员只需要变量体现原子性而不是在线程间同步共享数据。

## 获取/释放模式

第三种模式是前两种模式的混合体。获取/释放模式与顺序一致模式很像，但是它只应用*在...之前发生*于依赖变量。这允许在独立读取和独立写入之间宽松同步。

假设`x`和`y`都被初始化为0：

```cpp
-Thread 1-
y.store (20, memory_order_release);

-Thread 2-
x.store (10, memory_order_release);

-Thread 3-
assert (y.load (memory_order_acquire) == 20 && x.load (memory_order_acquire) == 0)

-Thread 4-
assert (y.load (memory_order_acquire) == 0 && x.load (memory_order_acquire) == 10)
```
两个断言都可以通过，毕竟线程1和线程2的两次存储没有强加任何关系。

如果这个例子使用顺序一致模型来写的话，那其中的一次存储必然要*在*另一次存储*之前发生*（即使顺序直到运行时才确定），而后变量值在线程之间同步，如果一个断言通过，那么另外一个断言一定失败。

把事情变得更复杂一些，非原子变量的相互作用还是不变的，任何发生在原子操作之前的存储必须被同步的其他线程可见。例如：

```cpp
-Thread 1-
y = 20;
x.store (10, memory_order_release);

-Thread 2-
if (x.load(memory_order_acquire) == 10)
   assert (y == 20);
```

因为`y`不是一个原子变量，对`y`的存储在对`x`的存储之前发生，所以在这种情况下断言不会失败。优化器必须限制对原子操作附近共享内存变量的操作。

## 消费模式

`std:memory_order_consume`是对获取/释放模式进一步细微的改进，它稍稍放宽了要求，去除了对非依赖共享变量的顺序要求。

假设`n`与`m`都是一般共享变量，初始化为0，并且每一个线程尝试获取线程1存储到p的值：

```cpp
-Thread 1-
n = 1
m = 1
p.store (&n, memory_order_release)

-Thread 2-
t = p.load (memory_order_acquire);
assert( *t == 1 && m == 1 );

-Thread 3-
t = p.load (memory_order_consume);
assert( *t == 1 && m == 1 );
```

线程2中的断言会通过，因为在线程1存储到`m`在存储到`p`之前发生。

线程3中的断言则可以失败，因为存储到`p`与存储到`m`之间不再有依赖关系，于是它们的值不再需要同步。这是PowerPC以及ARM架构指针加载的默认内存顺序。（也有可能是某些MIPs的模型）。

两个线程都可以看到n为1这个正确的值，因为它用在了存储表达式中。

真正测差别则归结为硬件到底要刷新多少个状态从而保持同步。既然一个消费操作执行得更快，那些知道自己在做什么的人可以使用它来写那些对性能极其敏感的应用程序。

##总结

内存模型同步模式并没有想得那么复杂，所以我们尝试在不同的内存模型下检查下边这个例子：

```cpp
 -Thread 1-       -Thread 2-                   -Thread 3-
 y.store (20);    if (x.load() == 10) {        if (y.load() == 10)
 x.store (10);      assert (y.load() == 20)      assert (x.load() == 10)
                    y.store (10)
                  }
```

当两个线程在顺序一致模式下同步时，所有可见的变量都必须在整个系统内刷新从而使所有线程看到相同的状态。两个断言因此都必须为真。

获取/释放模式只需要考虑参与同步的两个线程。这意味着被同步的值是交换不到其他线程去的。线程2中的断言必须为真，因为线程1与线程2通过`x.load()`同步。线程3没有参与到这一次同步，所以当线程2与线程3通过`y.load()`同步时，线程3的断言是可以失败的。线程1与线程3之间没有同步机制，所以没有办法在那里假设`x`的值。

如果存储动作标记为释放而加载标记为消费模式，那么结果与获取/释放模式是一样的，只是大概少了一些硬件上的同步。那为什么不每一次都用消费模式呢？因为在这个例子中，没有同步共享的内存。在同步过程中你也许不会看到任何共享内存的值，除非它是存储的一个参数，比如只是同步了共享内存变量从而计算存储的值。

如果所有的都是宽松模式，那么两个断言都可以失败，因为这里一点同步都没有。

### 把这些内存模型混起来

最后，我们把它们混起来用，比如：

```cpp
-Thread 1-
y.store (20, memory_order_relaxed)
x.store (10, memory_order_seq_cst)

-Thread 2-
if (x.load (memory_order_relaxed) == 10)
{
  assert (y.load(memory_order_seq_cst) == 20) // assert A
  y.store (10, memory_order_relaxed)
}

-Thread 3-
if (y.load (memory_order_acquire) == 10)
  assert (x.load(memory_order_acquire) == 10) // assert B
```

首先，别这么干，这会让人非常费解！:-)

其次，它还是一个普通的问题，所以尝试去解决它。。。考虑每一次同步的时候都发生了些什么。存储动作倾向于执行存储，然后执行任何在当前CPU上需要执行的系统层面刷新。读取动作则会发出任何需要的同步指令从而获取刷新了的状态，然后再执行读取。

线程1：`y.store`是宽松模式，所以它不发出任何同步动作，可以被移来移去。`x.store`是顺序一致模式，所以它强制在执行前刷新线程1状态。并且在这次同步之前的某个时间强制存储y。

线程2：`x.load`是宽松模式，所以它不会强制任何同步动作。虽然线程1在系统层面刷新了状态，但是线程2不做任何事情保证它自己与系统同步。这意味着所有变量都处于未知状态。假如碰巧看到了10这个值，这也并不意味着它同步了线程1中发生在`x.store(10)`之前的所有操作。

更神奇的是，读取y值将会强制一次同步，所以自从那之后所有的事情都可以你想象的一致了。够混乱吧？

线程3：`y.load`是获取模式，所以它会首先得到线程2刷新的任何值。然而，`y.store`在线程2中是宽松模式，所以它不会发出任何刷新指令，还有可能被优化器挪来挪去。所以结果又一次是非常不确定的。

所以混合模式是非常危险的，尤其是在引入了宽松模式之后。把顺序一致模式和获取/释放模式混合起来还可以细心处理一下，但是你必须对这些细微差别有完整的了解。也许你还需要有好的调试工具。
